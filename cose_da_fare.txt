!!!!IMPLEMTARE RESULT PER TUTTI I COMPONETI OLTRE a (CACHE MANAGER,ram, operands) al moemnto la propagazione
di result si ferma al fethc in cu e nell istruiction!!!

//READ CROOS LINES CACHE (in teroai va tutto)
//WRITE CROSSLINES CACHE

//per testare move su ram leggi cache no ram perch eram non viene scritta  fino a sostituzioen della linea

//funzioni per modificare grandezza rame e cache
//finire di sistemare cahce (capire eprceh non runna)
////modificare grandezza memoria dal bus

//flame grafh

//controllo big indian 

//controllare i prefissi sbaglaiti (ad esempio 0x66 quando ho 8 bit)

//capire cosa fare con prefisso 0x67

//alto livello: separazione tra instruction e visitor



controllare overflow neL CALCOLO DEGLI INDIRIZZI





//controllo erroi in decodifica c6 e c7 move, se reg non è 000 errore



//Uso della costante 0b111 per il controllo dei bit (MASK)


//aggiungere metodi per accedere ai byte inferiori di tutti i registri


//gestire errori



///NOTE//

non esisto i registri alti per 8 bit AH, CH, DH, BH vengono sempre utilizzati SPL, BPL, SIL, DIL (gli ultimi 8 bit finali di RSP, RBP, RSI, RDI), come se ci fosse sempre il prefisso rex

solo long mode 64 bit

i nomi dei egistri non cambiano in base alla grandezza, pero posso scrivere 8/16/32 nei registri a 64 bit

solo alu, no fpu, no vector unit, solo gpr e siene cs e ss e rimasugli da 32 bit

ficnhe non implementiamo un claock, lastaccesedtime della linea è un conattore quindi non si usa la politica LRU ma si guarda quella meno usata




IF(DENTRO OFSET)

PUNTATORE A FUNZIONE (O QUALSIASI ALTRA COSA) =FUNZIONE 1

ELSE PUNTATORE A FUNZIONE(O QUALSIASI ALTRA COSA) =FUNZIONE 2